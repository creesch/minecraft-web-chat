<!DOCTYPE html>
<html>
<head>
    <title>Minecraft Chat</title>
    <link rel="icon" type="image/png" sizes="32x32" href="icon_32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icon_16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="icon_180.png">
    <link rel="manifest" href="site.webmanifest">
    <style>
        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #2c2c2c;
            color: #ffffff;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #container {
            flex: 1;
            display: flex;
            flex-direction: column;
            margin: 1rem;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            overflow: hidden;
        }

        #messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column-reverse; /* Makes new messages appear at bottom */
        }

        .message {
            margin: 4px 0;
            padding: 4px 0;
            word-wrap: break-word;
        }

        #input-area {
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.2);
            display: flex;
            gap: 10px;
        }

        #messageInput {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 4px;
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 16px;
        }

        #messageInput:focus {
            outline: none;
            background-color: rgba(255, 255, 255, 0.15);
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            font-size: 16px;
        }

        button:hover {
            background-color: #45a049;
        }

        #status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 4px;
            background-color: rgba(0, 0, 0, 0.5);
            font-size: 14px;
        }

        .status-connected {
            color: #4CAF50;
        }

        .status-disconnected {
            color: #f44336;
        }

        #messages {
            scrollbar-width: thin; 
            scrollbar-color: rgba(255, 255, 255, 0.2) rgba(0, 0, 0, 0.1); 
            
            scrollbar-gutter: stable;
        }

        .message a {
            color: #4CAF50;
            text-decoration: none;
        }

        .message a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
<div id="container">
    <div id="messages"></div>
    <div id="input-area">
        <input type="text" id="messageInput" placeholder="Type your message...">
        <button onclick="sendMessage()">Send</button>
    </div>
</div>
<div id="status" class="status-disconnected">Disconnected</div>

<script>
    let ws;
    const wsPort = parseInt(location.port, 10) + 1;
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 5; // TODO: add a reconnect button after automatic retries are done.
    
    // TODO: probably make max stored messages a config
    const maxStoredMessages = 5000; // Max number of messages to keep in storage. 

    // Load previous messages when page loads
    function loadStoredMessages() {
        const stored = localStorage.getItem('chatMessages');
        if (stored) {
            const messages = JSON.parse(stored);
            // Reverse the array to show messages in correct order
            messages.reverse().forEach(msg => addMessage(msg, false));
        }
    }

    // Store messages in localStorage
    function storeMessage(text) {
        let messages = [];
        const stored = localStorage.getItem('chatMessages');
        if (stored) {
            messages = JSON.parse(stored);
        }

        messages.unshift(text); // Add new message at start

        // Keep only the last maxStoredMessages messages
        if (messages.length > maxStoredMessages) {
            messages = messages.slice(0, maxStoredMessages);
        }

        localStorage.setItem('chatMessages', JSON.stringify(messages));
    }

    // Convert URLs to clickable links
    function linkifyText(text) {
        const urlRegex = /(https?:\/\/[^\s]+)/g;
        return text.replace(urlRegex, url => `<a href="${url}" target="_blank">${url}</a>`);
    }

    function escapeHtml (unsafe) {
        return unsafe
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#039;');
    }

    function addMessage(text, store = true) {
        console.log(text);
        const div = document.createElement('div');
        div.className = 'message';
        // Escape the text first, then linkify
        const escapedText = escapeHtml(text);
        console.log(escapedText);
        const linkifiedText = linkifyText(escapedText);
        div.innerHTML = linkifiedText;
        const messages = document.getElementById('messages');
        messages.insertBefore(div, messages.firstChild);

        if (store) {
            // Note, we store the original text as on reload all messages go through this function again anyway. 
            storeMessage(text);
        }
    }

    function connect() {
        const
        ws = new WebSocket(`ws://localhost:${wsPort}`);

        ws.onopen = function() {
            console.log('Connected to server');
            const status = document.getElementById('status');
            status.textContent = 'Connected';
            status.className = 'status-connected';
            reconnectAttempts = 0;
        };

        ws.onclose = function() {
            const status = document.getElementById('status');
            status.textContent = 'Disconnected';
            status.className = 'status-disconnected';
            console.log('Connection closed. Attempting to reconnect...');

            if (reconnectAttempts < maxReconnectAttempts) {
                reconnectAttempts++;
                setTimeout(connect, 2000);
            }
        };

        ws.onerror = function(error) {
            console.error('WebSocket error:', error);
            document.getElementById('status').textContent = 'Error: ' + error;
        };

        ws.onmessage = function(event) {
            addMessage(event.data);
        };
    }

    function sendMessage() {
        // TODO: cut message up if it is too long and send in parts. Possibly do this server side... 
        const input = document.getElementById('messageInput');
        if (ws && ws.readyState === WebSocket.OPEN && input.value.trim()) {
            ws.send(input.value);
            input.value = '';
        } else if (!input.value.trim()) {
            return;
        } else {
            console.log('WebSocket is not connected');
            const status = document.getElementById('status');
            status.textContent = 'Not connected - message not sent';
            status.className = 'status-disconnected';
        }
    }

    // Start connection and load stored messages when page loads
    connect();
    loadStoredMessages();

    // Allow Enter key to send messages
    document.getElementById('messageInput').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            sendMessage();
        }
    });

    // Focus input on load
    document.getElementById('messageInput').focus();
</script>
</body>
</html>